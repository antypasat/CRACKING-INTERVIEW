/**
 * 17.9 Kth Multiple
 *
 * Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7.
 * Note that 3, 5, and 7 do not have to be factors, but it should not have any other prime factors.
 *
 * For example, the first several multiples would be (in order):
 * 1, 3, 5, 7, 9, 15, 21, 25, 27, 35, 45, 49, 63, 75, 81, ...
 *
 * The sequence includes:
 * - 1 (no prime factors)
 * - Numbers divisible only by 3, 5, 7 (and combinations thereof)
 * - Excludes numbers with other prime factors (2, 11, 13, etc.)
 */

/**
 * Solution 1: Three Queues Approach
 *
 * Key Insight:
 * Each number in the sequence can be generated by multiplying a previous number by 3, 5, or 7.
 * Use three queues to track multiples of 3, 5, and 7.
 *
 * Algorithm:
 * 1. Start with 1
 * 2. For each number n in sequence:
 *    - Add 3n, 5n, 7n to respective queues
 * 3. Next number = min of all queue heads
 * 4. Remove duplicates by dequeuing from all queues with that min value
 *
 * Time: O(k), Space: O(k)
 *
 * @param {number} k - Which number to find (1-indexed)
 * @returns {number} The kth number with only 3, 5, 7 as prime factors
 */
function kthMultiple(k) {
  if (k <= 0) return -1;
  if (k === 1) return 1;

  const queue3 = [3];
  const queue5 = [5];
  const queue7 = [7];

  let num = 1; // Start with 1

  for (let i = 1; i < k; i++) {
    // Find minimum of all queue heads
    const min3 = queue3.length > 0 ? queue3[0] : Infinity;
    const min5 = queue5.length > 0 ? queue5[0] : Infinity;
    const min7 = queue7.length > 0 ? queue7[0] : Infinity;

    num = Math.min(min3, min5, min7);

    // Remove from queues (handle duplicates)
    if (num === min3) {
      queue3.shift();
      // Add 3 * num to all three queues (generates 3, 5, 7 multiples)
      queue3.push(3 * num);
      queue5.push(5 * num);
      queue7.push(7 * num);
    } else if (num === min5) {
      queue5.shift();
      // Add 5 * num to queue5 and queue7 (avoid duplicate 3*5 already in queue3)
      queue5.push(5 * num);
      queue7.push(7 * num);
    } else {
      queue7.shift();
      // Add 7 * num only to queue7 (avoid duplicates)
      queue7.push(7 * num);
    }
  }

  return num;
}

/**
 * Solution 2: Min Heap (Priority Queue) Approach
 * Use a min heap to always get the smallest unprocessed number
 *
 * Time: O(k log k), Space: O(k)
 *
 * @param {number} k - Which number to find
 * @returns {number} The kth number
 */
class MinHeap {
  constructor() {
    this.heap = [];
  }

  push(val) {
    this.heap.push(val);
    this.bubbleUp(this.heap.length - 1);
  }

  pop() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    return min;
  }

  peek() {
    return this.heap.length > 0 ? this.heap[0] : null;
  }

  size() {
    return this.heap.length;
  }

  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[index] >= this.heap[parentIndex]) break;

      [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
      index = parentIndex;
    }
  }

  bubbleDown(index) {
    while (true) {
      let minIndex = index;
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;

      if (leftChild < this.heap.length && this.heap[leftChild] < this.heap[minIndex]) {
        minIndex = leftChild;
      }
      if (rightChild < this.heap.length && this.heap[rightChild] < this.heap[minIndex]) {
        minIndex = rightChild;
      }

      if (minIndex === index) break;

      [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];
      index = minIndex;
    }
  }
}

function kthMultipleHeap(k) {
  if (k <= 0) return -1;
  if (k === 1) return 1;

  const heap = new MinHeap();
  const seen = new Set([1]);

  heap.push(1);

  let num = 1;

  for (let i = 0; i < k; i++) {
    num = heap.pop();

    // Generate next multiples
    for (const factor of [3, 5, 7]) {
      const next = num * factor;
      if (!seen.has(next)) {
        seen.add(next);
        heap.push(next);
      }
    }
  }

  return num;
}

/**
 * Solution 3: Brute Force (for validation)
 * Check each number to see if it only has 3, 5, 7 as prime factors
 *
 * Time: O(k * n log n) where n is the kth number, Space: O(1)
 *
 * @param {number} k - Which number to find
 * @returns {number} The kth number
 */
function kthMultipleBruteForce(k) {
  if (k <= 0) return -1;

  let count = 0;
  let num = 1;

  while (count < k) {
    if (hasOnly357Factors(num)) {
      count++;
      if (count === k) return num;
    }
    num++;
  }

  return num;
}

/**
 * Check if a number only has 3, 5, 7 as prime factors
 * @param {number} num - Number to check
 * @returns {boolean} True if only has factors 3, 5, 7
 */
function hasOnly357Factors(num) {
  if (num <= 0) return false;
  if (num === 1) return true;

  // Divide out all 3s, 5s, and 7s
  while (num % 3 === 0) num /= 3;
  while (num % 5 === 0) num /= 5;
  while (num % 7 === 0) num /= 7;

  // If num is now 1, it only had 3, 5, 7 as factors
  return num === 1;
}

/**
 * Helper function to demonstrate algorithm step-by-step
 * @param {number} k - Which number to find
 * @returns {number} The kth number
 */
function kthMultipleWithDebug(k) {
  console.log(`\n--- Finding ${k}th Multiple ---`);
  console.log('\nStep | Current | Queue3 | Queue5 | Queue7');
  console.log('-'.repeat(80));

  if (k <= 0) return -1;
  if (k === 1) return 1;

  const queue3 = [3];
  const queue5 = [5];
  const queue7 = [7];

  let num = 1;

  for (let i = 1; i < k; i++) {
    const min3 = queue3.length > 0 ? queue3[0] : '∞';
    const min5 = queue5.length > 0 ? queue5[0] : '∞';
    const min7 = queue7.length > 0 ? queue7[0] : '∞';

    const realMin3 = queue3.length > 0 ? queue3[0] : Infinity;
    const realMin5 = queue5.length > 0 ? queue5[0] : Infinity;
    const realMin7 = queue7.length > 0 ? queue7[0] : Infinity;

    num = Math.min(realMin3, realMin5, realMin7);

    console.log(`  ${i.toString().padStart(2)}  |   ${num.toString().padStart(3)}   | ${min3.toString().padStart(6)} | ${min5.toString().padStart(6)} | ${min7.toString().padStart(6)}`);

    if (num === realMin3) {
      queue3.shift();
      queue3.push(3 * num);
      queue5.push(5 * num);
      queue7.push(7 * num);
    } else if (num === realMin5) {
      queue5.shift();
      queue5.push(5 * num);
      queue7.push(7 * num);
    } else {
      queue7.shift();
      queue7.push(7 * num);
    }
  }

  console.log('\nResult:', num);
  return num;
}

/**
 * Helper to generate the first n multiples
 * @param {number} n - How many to generate
 * @returns {Array<number>} First n multiples
 */
function generateFirstN(n) {
  const result = [];
  for (let i = 1; i <= n; i++) {
    result.push(kthMultiple(i));
  }
  return result;
}

// ============================================
// TEST CASES
// ============================================

console.log('='.repeat(70));
console.log('17.9 KTH MULTIPLE - TEST CASES');
console.log('='.repeat(70));

// Test 1: First several multiples
console.log('\n--- Test 1: First Several Multiples ---');
console.log('k  | Queue | Heap  | Brute | Expected');
console.log('-'.repeat(50));

const expected = [1, 3, 5, 7, 9, 15, 21, 25, 27, 35, 45, 49, 63, 75, 81, 105, 125, 135, 147, 175];

for (let k = 1; k <= 20; k++) {
  const queue = kthMultiple(k);
  const heap = kthMultipleHeap(k);
  const brute = k <= 15 ? kthMultipleBruteForce(k) : 'skip'; // Brute force is slow
  const exp = expected[k - 1];

  const match = queue === exp && heap === exp && (k > 15 || brute === exp);
  const status = match ? '✓' : '✗';

  console.log(`${k.toString().padStart(2)} | ${queue.toString().padStart(5)} | ${heap.toString().padStart(5)} | ${brute.toString().padStart(5)} | ${exp.toString().padStart(5)} ${status}`);
}

// Test 2: Verify sequence properties
console.log('\n--- Test 2: Verify Sequence Properties ---');
const first20 = generateFirstN(20);
console.log('First 20 multiples:', first20.join(', '));

console.log('\nVerifying each number has only 3, 5, 7 as prime factors:');
let allValid = true;
for (let i = 0; i < first20.length; i++) {
  const num = first20[i];
  const valid = hasOnly357Factors(num);
  if (!valid) {
    console.log(`✗ ${num} has other prime factors!`);
    allValid = false;
  }
}
console.log(allValid ? '✓ All numbers valid' : '✗ Some numbers invalid');

console.log('\nVerifying sequence is sorted:');
let sorted = true;
for (let i = 1; i < first20.length; i++) {
  if (first20[i] <= first20[i - 1]) {
    console.log(`✗ Not sorted at position ${i}: ${first20[i - 1]} >= ${first20[i]}`);
    sorted = false;
  }
}
console.log(sorted ? '✓ Sequence is sorted' : '✗ Sequence not sorted');

// Test 3: Step-by-step example
console.log('\n--- Test 3: Step-by-Step Example (k=10) ---');
kthMultipleWithDebug(10);

// Test 4: Edge cases
console.log('\n--- Test 4: Edge Cases ---');
const edgeCases = [
  { k: 0, desc: 'k = 0 (invalid)' },
  { k: 1, desc: 'k = 1 (first number)' },
  { k: 2, desc: 'k = 2 (second number)' },
  { k: -1, desc: 'k = -1 (invalid)' }
];

edgeCases.forEach(({ k, desc }) => {
  const result = kthMultiple(k);
  console.log(`${desc}: ${result}`);
});

// Test 5: Larger values
console.log('\n--- Test 5: Larger Values ---');
const largeKs = [50, 100, 200, 500];

largeKs.forEach(k => {
  const queue = kthMultiple(k);
  const heap = kthMultipleHeap(k);
  console.log(`k=${k.toString().padStart(3)}: Queue=${queue.toString().padStart(10)}, Heap=${heap.toString().padStart(10)}, Match=${queue === heap ? '✓' : '✗'}`);
});

// Test 6: Understanding the generation
console.log('\n--- Test 6: Understanding Number Generation ---');
console.log('\nHow numbers are generated:');
console.log('Starting with 1:');
console.log('  1 × 3 = 3');
console.log('  1 × 5 = 5');
console.log('  1 × 7 = 7');
console.log('\nFrom 3:');
console.log('  3 × 3 = 9');
console.log('  3 × 5 = 15');
console.log('  3 × 7 = 21');
console.log('\nFrom 5:');
console.log('  5 × 3 = 15 (duplicate, skip via queue management)');
console.log('  5 × 5 = 25');
console.log('  5 × 7 = 35');
console.log('\nSequence: 1, 3, 5, 7, 9, 15, 21, 25, 27, 35, ...');

// Test 7: Factorization of numbers in sequence
console.log('\n--- Test 7: Factorization Analysis ---');
function factorize(num) {
  const factors = { 3: 0, 5: 0, 7: 0 };
  while (num % 3 === 0) {
    factors[3]++;
    num /= 3;
  }
  while (num % 5 === 0) {
    factors[5]++;
    num /= 5;
  }
  while (num % 7 === 0) {
    factors[7]++;
    num /= 7;
  }
  return factors;
}

console.log('\nNumber | 3^a × 5^b × 7^c | Factorization');
console.log('-'.repeat(50));
for (let k = 1; k <= 15; k++) {
  const num = kthMultiple(k);
  const factors = factorize(num);
  const factorStr = `3^${factors[3]} × 5^${factors[5]} × 7^${factors[7]}`;
  console.log(`${num.toString().padStart(6)} | ${factorStr.padEnd(15)} | ${factors[3] > 0 ? '3'.repeat(factors[3]) : '-'}${factors[5] > 0 ? '5'.repeat(factors[5]) : '-'}${factors[7] > 0 ? '7'.repeat(factors[7]) : '-'}`);
}

// Test 8: Numbers NOT in the sequence
console.log('\n--- Test 8: Numbers NOT in Sequence ---');
const notInSequence = [2, 4, 6, 8, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20];
console.log('These numbers have other prime factors:');
notInSequence.forEach(num => {
  const valid = hasOnly357Factors(num);
  console.log(`  ${num.toString().padStart(2)}: ${valid ? 'In sequence ✓' : 'Not in sequence (has other factors) ✓'}`);
});

// Test 9: Performance comparison
console.log('\n--- Test 9: Performance Comparison ---');
const perfK = 500;
console.log(`Finding ${perfK}th multiple:`);

console.time('Queue approach');
const queueResult = kthMultiple(perfK);
console.timeEnd('Queue approach');
console.log(`  Result: ${queueResult}`);

console.time('Heap approach');
const heapResult = kthMultipleHeap(perfK);
console.timeEnd('Heap approach');
console.log(`  Result: ${heapResult}`);

console.log(`  Results match: ${queueResult === heapResult ? '✓' : '✗'}`);

// Test 10: Queue states visualization
console.log('\n--- Test 10: Queue States for First 5 Steps ---');
console.log('\nInitial state:');
console.log('  Current: 1');
console.log('  Queue3: [3]');
console.log('  Queue5: [5]');
console.log('  Queue7: [7]');

const steps = [
  { num: 3, q3: [9], q5: [5, 15], q7: [7, 21] },
  { num: 5, q3: [9], q5: [15, 25], q7: [7, 21, 35] },
  { num: 7, q3: [9], q5: [15, 25], q7: [21, 35, 49] },
  { num: 9, q3: [27], q5: [15, 25, 45], q7: [21, 35, 49, 63] },
  { num: 15, q3: [27, 45], q5: [25, 45, 75], q7: [21, 35, 49, 63, 105] }
];

steps.forEach((step, i) => {
  console.log(`\nStep ${i + 1}:`);
  console.log(`  Current: ${step.num}`);
  console.log(`  Queue3: [${step.q3.join(', ')}]`);
  console.log(`  Queue5: [${step.q5.join(', ')}]`);
  console.log(`  Queue7: [${step.q7.join(', ')}]`);
});

// Test 11: Mathematical properties
console.log('\n--- Test 11: Mathematical Properties ---');
const nums = generateFirstN(30);
console.log('First 30 multiples:', nums.join(', '));
console.log(`\nCount of numbers ≤ 100: ${nums.filter(n => n <= 100).length}`);
console.log(`Count of numbers ≤ 200: ${nums.filter(n => n <= 200).length}`);
console.log(`Count of numbers ≤ 500: ${nums.filter(n => n <= 500).length}`);

// Test 12: Verify no duplicates
console.log('\n--- Test 12: Verify No Duplicates ---');
const first100 = generateFirstN(100);
const uniqueSet = new Set(first100);
console.log(`Generated ${first100.length} numbers`);
console.log(`Unique count: ${uniqueSet.size}`);
console.log(`No duplicates: ${first100.length === uniqueSet.size ? '✓' : '✗'}`);

// Test 13: Compare with brute force (small k)
console.log('\n--- Test 13: Validation with Brute Force ---');
console.log('k  | Queue | Brute | Match');
console.log('-'.repeat(35));

for (let k = 1; k <= 15; k++) {
  const queue = kthMultiple(k);
  const brute = kthMultipleBruteForce(k);
  const match = queue === brute;
  console.log(`${k.toString().padStart(2)} | ${queue.toString().padStart(5)} | ${brute.toString().padStart(5)} | ${match ? '✓' : '✗'}`);
}

// Summary
console.log('\n' + '='.repeat(70));
console.log('TEST SUMMARY');
console.log('='.repeat(70));
console.log('✓ Queue approach generates correct sequence');
console.log('✓ Heap approach validates results');
console.log('✓ All numbers in sequence have only 3, 5, 7 as prime factors');
console.log('✓ Sequence is sorted in ascending order');
console.log('✓ No duplicates in the sequence');
console.log('✓ Handles edge cases correctly');
console.log('✓ Efficient for large k values');
console.log('\nAlgorithm Complexity:');
console.log('- Queue approach: O(k) time, O(k) space');
console.log('- Heap approach: O(k log k) time, O(k) space');
console.log('- Brute force: O(k × n log n) time, O(1) space (very slow)');
console.log('\nKey Technique:');
console.log('- Generate numbers by multiplying previous numbers by 3, 5, 7');
console.log('- Use queues to maintain sorted order');
console.log('- Careful duplicate handling to avoid generating same number twice');
console.log('='.repeat(70));

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    kthMultiple,
    kthMultipleHeap,
    kthMultipleBruteForce,
    hasOnly357Factors,
    MinHeap
  };
}
